# IT物资全生命周期管理系统｜状态机定义（草案）

## 1. Application 状态机（申领/退库/维修共用骨架）

说明书主链路：申请提交 → 库存预占(Lock) → 领导初审 → 管理员复审 → 待出库 → 完成。

### 1.1 状态枚举

- SUBMITTED：已提交，尚未锁库（可选，若创建即锁库可跳过）
- LOCKED：已锁库（预占具体 Asset 实例，Asset.status=LOCKED）
- LEADER_APPROVED：领导通过
- LEADER_REJECTED：领导驳回
- ADMIN_APPROVED：管理员通过（并完成 Asset 分配确认）
- ADMIN_REJECTED：管理员驳回
- READY_OUTBOUND：待出库（自取或待发货）
- OUTBOUNDED：已交付（自取确认交付完成）
- SHIPPED：已发货（快递单已录入）
- DONE：完结（自取可直接从 OUTBOUNDED 进入 DONE；快递可在签收后进入 DONE）
- CANCELLED：已取消（仅允许在未出库前）

### 1.2 事件与流转

| 事件 | 触发方 | 前置状态 | 目标状态 | 副作用 |
|---|---|---|---|---|
| create_application | USER | - | SUBMITTED/LOCKED | 生成 pickup_code；写 Application + ApplicationItem |
| lock_inventory | SYSTEM | SUBMITTED | LOCKED | 选择可用 Asset；置 Asset.status=LOCKED；写 StockFlow(LOCK) |
| leader_approve | LEADER | LOCKED | LEADER_APPROVED | 写 ApprovalHistory |
| leader_reject | LEADER | LOCKED | LEADER_REJECTED | 解锁 Asset→IN_STOCK；写 StockFlow(UNLOCK) |
| admin_approve | ADMIN | LEADER_APPROVED | ADMIN_APPROVED | 确认/补充分配 Asset；写 ApprovalHistory |
| admin_reject | ADMIN | LEADER_APPROVED | ADMIN_REJECTED | 解锁 Asset→IN_STOCK；写 StockFlow(UNLOCK) |
| mark_ready_outbound | SYSTEM/ADMIN | ADMIN_APPROVED | READY_OUTBOUND | 生成/刷新 pickup_qr_string |
| confirm_pickup | ADMIN | READY_OUTBOUND | OUTBOUNDED | Asset→IN_USE；holder_user_id=申请人；写 StockFlow(OUTBOUND) |
| ship_express | ADMIN | READY_OUTBOUND | SHIPPED | 写 Logistics；写 StockFlow(SHIPPED 可选) |
| confirm_received | USER/ADMIN | SHIPPED | DONE | 写 StockFlow(RECEIVED 可选) |
| close_done | SYSTEM | OUTBOUNDED | DONE | 完结 |
| cancel | USER/ADMIN | SUBMITTED/LOCKED/LEADER_APPROVED/ADMIN_APPROVED/READY_OUTBOUND | CANCELLED | 若已锁库则解锁 Asset；写 StockFlow(CANCEL) |

### 1.3 关键一致性规则

- LOCKED 必须绑定“具体 Asset 实例”，禁止只锁定“数字库存”
- 任意驳回/取消在出库前都必须“解锁 Asset → IN_STOCK”
- 自取确认交付后，Asset 必须同时满足：
  - status=IN_USE（或组织定义的 BORROWED）
  - holder_user_id=申请人
  - StockFlow 有 OUTBOUND 记录

## 2. Asset 状态机

### 2.1 状态枚举

- IN_STOCK：在库可用
- LOCKED：被某申请单预占
- IN_USE：已交付在用（持有人非空）
- PENDING_INSPECTION：归还待验收（资产已回收流程中，暂不可再次分配）
- BORROWED：借出（可选，若与 IN_USE 语义区分）
- REPAIRING：维修中
- SCRAPPED：报废

### 2.2 事件与流转（核心）

| 事件 | 前置 | 目标 | 说明 |
|---|---|---|---|
| inbound | - | IN_STOCK | 入库创建 Asset |
| lock | IN_STOCK | LOCKED | 申请预占 |
| unlock | LOCKED | IN_STOCK | 驳回/取消/超时释放 |
| outbound_pickup | LOCKED | IN_USE | 自取交付 |
| outbound_ship | LOCKED | IN_USE | 快递发货可同时置为 IN_USE（以“已发货即交付”语义）；也可扩展为“IN_TRANSIT” |
| return_asset | IN_USE | PENDING_INSPECTION | 用户发起归还，进入待验收 |
| confirm_return_pass | PENDING_INSPECTION | IN_STOCK | 管理员验收通过，回库可用 |
| confirm_return_fail | PENDING_INSPECTION | REPAIRING | 验收发现损坏，转入维修 |
| start_repair | IN_USE | REPAIRING | 故障报修（说明书快捷入口） |
| finish_repair | REPAIRING | IN_USE | 维修完成 |
| scrap | IN_STOCK/REPAIRING | SCRAPPED | 报废 |

## 3. 异常处理与超时机制

### 3.1 库存锁定超时释放

**场景**：申请单进入 LOCKED 状态后，长时间未完成审批导致资产长期被锁定

**策略**：

| 状态 | 超时时长 | 触发动作 |
|-----|---------|---------|
| LOCKED | 72 小时 | 自动取消申请，解锁资产 |
| LEADER_APPROVED | 48 小时 | 自动取消申请，解锁资产 |
| ADMIN_APPROVED | 48 小时 | 自动取消申请，解锁资产 |
| READY_OUTBOUND | 7 天 | 自动取消申请，解锁资产 |

**实现方式**：

```python
# 定时任务（Celery Beat）示例
@celery.task
def release_expired_locks():
    """每小时执行一次，释放超时锁定"""
    timeout_rules = {
        "LOCKED": timedelta(hours=72),
        "LEADER_APPROVED": timedelta(hours=48),
        "ADMIN_APPROVED": timedelta(hours=48),
        "READY_OUTBOUND": timedelta(days=7),
    }
    
    for status, timeout in timeout_rules.items():
        expired_apps = get_applications_by_status_and_timeout(status, timeout)
        
        for app in expired_apps:
            with transaction():
                # 解锁资产
                unlock_assets(app.id)
                # 更新申请单状态
                app.status = "CANCELLED"
                app.cancel_reason = "TIMEOUT_AUTO_CANCELLED"
                app.save()
                # 写流水
                create_stock_flow(app.id, "TIMEOUT_UNLOCK")
                # 发送通知
                send_timeout_notification(app.applicant_user_id, app.id)
```

### 3.2 新增事件：timeout_unlock_inventory

| 事件 | 触发方 | 前置状态 | 目标状态 | 副作用 |
|-----|-------|---------|---------|--------|
| timeout_unlock_inventory | SYSTEM_CRON | LOCKED / LEADER_APPROVED / ADMIN_APPROVED / READY_OUTBOUND | CANCELLED | 解锁 Asset→IN_STOCK；写 StockFlow(TIMEOUT_UNLOCK)；发送超时通知 |

### 3.3 并发锁定冲突处理

**场景**：多个申请单同时申请同一批资产

**策略**：

1. **数据库行级锁**（推荐）

```sql
-- 锁定可用资产时使用 FOR UPDATE
SELECT * FROM asset 
WHERE sku_id = ? 
  AND status = 'IN_STOCK' 
  AND locked_application_id IS NULL 
LIMIT ?
FOR UPDATE;
```

2. **乐观锁 + 重试**

```python
async def lock_assets_for_application(app_id: int, sku_id: int, quantity: int):
    """带重试的乐观锁"""
    max_retries = 3
    
    for attempt in range(max_retries):
        try:
            async with transaction():
                # 查询可用资产
                assets = await get_available_assets(sku_id, quantity)
                
                if len(assets) < quantity:
                    raise StockInsufficientError(sku_id, len(assets), quantity)
                
                # 乐观锁更新
                updated = await Asset.filter(
                    id__in=[a.id for a in assets],
                    status="IN_STOCK",  # 再次确认状态
                    locked_application_id__isnull=True  # 确保未被锁定
                ).update(
                    status="LOCKED",
                    locked_application_id=app_id,
                    updated_at=datetime.utcnow()
                )
                
                if updated != quantity:
                    # 并发冲突，重试
                    raise ConcurrencyConflictError()
                
                # 写流水
                await create_stock_flows(assets, "LOCK", app_id)
                return assets
                
        except ConcurrencyConflictError:
            if attempt == max_retries - 1:
                raise StockInsufficientError(sku_id, 0, quantity)
            await asyncio.sleep(0.1 * (2 ** attempt))  # 指数退避
```

### 3.4 状态流转前置校验

**防御性编程**：每次状态变更前强制校验当前状态

```python
class ApplicationStateMachine:
    """申请单状态机"""
    
    VALID_TRANSITIONS = {
        "LOCKED": ["LEADER_APPROVED", "LEADER_REJECTED", "CANCELLED"],
        "LEADER_APPROVED": ["ADMIN_APPROVED", "ADMIN_REJECTED", "CANCELLED"],
        "ADMIN_APPROVED": ["READY_OUTBOUND", "CANCELLED"],
        "READY_OUTBOUND": ["OUTBOUNDED", "SHIPPED", "CANCELLED"],
        # ...
    }
    
    @staticmethod
    def validate_transition(current: str, target: str):
        """校验状态流转是否合法"""
        allowed = ApplicationStateMachine.VALID_TRANSITIONS.get(current, [])
        
        if target not in allowed:
            raise ApplicationStatusInvalidError(
                f"不允许从 {current} 转换到 {target}，允许的状态：{allowed}"
            )
    
    @staticmethod
    async def transition_to(app_id: int, target_status: str, **kwargs):
        """执行状态流转（带校验）"""
        async with transaction():
            # 加锁查询当前状态
            app = await Application.select_for_update().get(id=app_id)
            
            # 校验流转合法性
            ApplicationStateMachine.validate_transition(app.status, target_status)
            
            # 执行状态变更
            app.status = target_status
            await app.save()
            
            # 执行副作用（解锁、写流水、发通知等）
            await execute_side_effects(app, target_status, **kwargs)
```

### 3.5 资产状态不一致修复

**场景**：因异常导致 `application.status` 与 `asset.status` 不同步

**检测脚本**（定时任务）：

```python
@celery.task
def detect_inconsistent_states():
    """检测状态不一致"""
    
    # 检测 1：申请已取消但资产仍被锁定
    inconsistent = await db.execute("""
        SELECT a.id, app.id, app.status
        FROM asset a
        JOIN application app ON a.locked_application_id = app.id
        WHERE a.status = 'LOCKED'
          AND app.status IN ('CANCELLED', 'LEADER_REJECTED', 'ADMIN_REJECTED', 'DONE')
    """)
    
    for asset_id, app_id, app_status in inconsistent:
        logger.warning(f"检测到不一致：Asset {asset_id} 被已{app_status}的 App {app_id} 锁定")
        # 自动修复：解锁资产
        await repair_unlock_asset(asset_id, app_id)
    
    # 检测 2：申请已出库但资产未变更持有人
    inconsistent = await db.execute("""
        SELECT a.id, app.applicant_user_id
        FROM application app
        JOIN application_asset aa ON app.id = aa.application_id
        JOIN asset a ON aa.asset_id = a.id
        WHERE app.status IN ('OUTBOUNDED', 'DONE')
          AND a.holder_user_id != app.applicant_user_id
    """)
    
    for asset_id, expected_holder in inconsistent:
        logger.warning(f"检测到不一致：Asset {asset_id} 持有人未更新")
        await repair_update_holder(asset_id, expected_holder)
```

### 3.6 异常状态扩展（可选）

若需要更精细的错误状态，可扩展枚举：

```sql
-- 申请单状态扩展
ALTER TABLE application 
MODIFY COLUMN status ENUM(
  'SUBMITTED', 'LOCKED', 
  'LEADER_APPROVED', 'LEADER_REJECTED',
  'ADMIN_APPROVED', 'ADMIN_REJECTED',
  'READY_OUTBOUND', 'OUTBOUNDED', 'SHIPPED', 'DONE',
  'CANCELLED',
  'TIMEOUT_CANCELLED',  -- 超时自动取消
  'SYSTEM_CANCELLED',   -- 系统异常取消
  'CONFLICT_CANCELLED'  -- 库存冲突取消
) NOT NULL;
```

### 3.7 错误码映射

| 状态机错误 | 错误码 | HTTP 状态 |
|----------|-------|----------|
| 库存不足锁定失败 | STOCK_INSUFFICIENT | 409 |
| 状态流转非法 | APPLICATION_STATUS_INVALID | 422 |
| 并发锁定冲突 | CONCURRENCY_CONFLICT | 409 |
| 资产已被锁定 | ASSET_LOCKED | 409 |
| 申请已审批 | ALREADY_APPROVED | 409 |

参见 [05-错误码与异常处理.md](./05-错误码与异常处理.md)。
