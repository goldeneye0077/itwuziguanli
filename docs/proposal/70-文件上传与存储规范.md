# IT物资全生命周期管理系统｜文件上传与存储规范（草案）

## 1. 文件分类

| 文件类型 | 用途 | 格式限制 | 大小限制 |
|---------|------|---------|---------|
| 物资图片 | SKU 封面图 | jpg, png, webp | 5 MB |
| 发票/送货单 | OCR 入库 | jpg, png, pdf | 10 MB |
| 合同文档 | 采购合同归档 | pdf, doc, docx | 20 MB |
| 资产标签二维码 | 打印用 | svg, png | 1 MB |
| 提货券二维码 | 邮件嵌入 | png | 500 KB |
| 用户头像 | 用户个人资料 | jpg, png | 2 MB |

## 2. 存储架构

### 2.1 MinIO 对象存储

**Bucket 规划**：

```yaml
Buckets:
  assets-images:      # 物资图片
    public: true
    cdn: true
    
  documents:          # 发票/合同
    public: false
    encryption: true
    
  qrcodes:            # 二维码
    public: false
    ttl: 30days       # 提货券二维码 30 天后自动删除
    
  avatars:            # 用户头像
    public: true
    cdn: true
    
  temp-uploads:       # 临时上传
    ttl: 24hours      # 24 小时后自动清理
```

### 2.2 文件命名规范

```
格式: {prefix}/{category}/{date}/{uuid}.{ext}

示例:
  assets-images/sku-covers/2026/02/550e8400-e29b-41d4-a716-446655440000.jpg
  documents/invoices/2026/02/7c9e6679-7425-40de-944b-e07fc1f90ae7.pdf
  qrcodes/pickup/2026/02/123456.png
```

## 3. 上传接口

### 3.1 通用上传接口

```yaml
POST /api/v1/upload
  
Content-Type: multipart/form-data

Request Body:
  file: binary
  category: string (enum: sku_cover, invoice, contract, avatar)
  
Response:
  {
    "success": true,
    "data": {
      "file_id": "uuid",
      "url": "https://cdn.example.com/assets/...",
      "file_name": "original_name.jpg",
      "file_size": 1024000,
      "mime_type": "image/jpeg",
      "uploaded_at": "2026-02-05T08:30:00Z"
    }
  }
```

### 3.2 分类专用上传

```yaml
# 物资图片上传
POST /api/v1/upload/sku-image
  限制: jpg/png, 5MB
  返回: CDN 公开链接

# 发票上传（OCR 入库）
POST /api/v1/upload/invoice
  限制: jpg/png/pdf, 10MB
  返回: 私有链接（预签名 URL）
  
# 头像上传
POST /api/v1/upload/avatar
  限制: jpg/png, 2MB
  自动: 裁剪为 200x200
  返回: CDN 公开链接
```

## 4. 文件处理

### 4.1 图片压缩

上传后自动生成多尺寸缩略图：

| 用途 | 尺寸 | 质量 |
|-----|------|------|
| 原图 | 原始 | 90% |
| 列表缩略图 | 400x300 | 80% |
| 详情大图 | 800x600 | 85% |
| 头像小图 | 200x200 | 85% |

```python
# 示例：Pillow 压缩
from PIL import Image

def compress_and_resize(input_path, sizes):
    img = Image.open(input_path)
    results = {}
    
    for size_name, (width, height, quality) in sizes.items():
        resized = img.resize((width, height), Image.LANCZOS)
        output_path = f"{uuid4()}_{size_name}.jpg"
        resized.save(output_path, "JPEG", quality=quality, optimize=True)
        results[size_name] = upload_to_minio(output_path)
    
    return results
```

### 4.2 文件类型校验

**前端校验**：

```typescript
// React 示例
const allowedTypes = {
  'sku_cover': ['image/jpeg', 'image/png', 'image/webp'],
  'invoice': ['image/jpeg', 'image/png', 'application/pdf'],
};

function validateFile(file: File, category: string): boolean {
  if (!allowedTypes[category].includes(file.type)) {
    message.error('不支持的文件格式');
    return false;
  }
  
  const maxSize = category === 'invoice' ? 10 * 1024 * 1024 : 5 * 1024 * 1024;
  if (file.size > maxSize) {
    message.error(`文件大小超过限制 ${maxSize / 1024 / 1024} MB`);
    return false;
  }
  
  return true;
}
```

**后端校验**：

```python
# FastAPI 示例
from magic import Magic

ALLOWED_MIMES = {
    "sku_cover": ["image/jpeg", "image/png", "image/webp"],
    "invoice": ["image/jpeg", "image/png", "application/pdf"],
}

async def validate_upload(file: UploadFile, category: str):
    """校验上传文件"""
    # 1. 检查文件名后缀
    ext = file.filename.split('.')[-1].lower()
    if ext not in ["jpg", "jpeg", "png", "webp", "pdf"]:
        raise ValidationError("不支持的文件格式")
    
    # 2. 读取文件头校验 MIME（防止伪造后缀）
    content = await file.read(2048)
    await file.seek(0)
    
    mime = Magic(mime=True).from_buffer(content)
    if mime not in ALLOWED_MIMES[category]:
        raise ValidationError(f"文件 MIME 类型不匹配：{mime}")
    
    # 3. 检查文件大小
    await file.seek(0, 2)  # 移动到文件末尾
    size = await file.tell()
    await file.seek(0)
    
    if size > MAX_FILE_SIZE[category]:
        raise ValidationError("文件大小超过限制")
```

## 5. MinIO 配置

### 5.1 Docker Compose 配置

> 请勿在仓库中提交固定默认账号密码，统一通过环境变量注入。

```yaml
services:
  minio:
    image: minio/minio:latest
    ports:
      - "127.0.0.1:9000:9000"
      - "127.0.0.1:9001:9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:?set in .env}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:?set in .env}
    volumes:
      - ./data/minio:/data
    command: server /data --console-address ":9001"
    
  minio-init:
    image: minio/mc:latest
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD};
      mc mb myminio/assets-images;
      mc mb myminio/documents;
      mc mb myminio/qrcodes;
      mc mb myminio/avatars;
      mc policy set public myminio/assets-images;
      mc policy set public myminio/avatars;
      "
```

### 5.2 Python SDK 使用

```python
import os
from minio import Minio

minio_client = Minio(
    os.getenv("MINIO_ENDPOINT", "localhost:9000"),
    access_key=os.getenv("MINIO_ACCESS_KEY"),
    secret_key=os.getenv("MINIO_SECRET_KEY"),
    secure=os.getenv("MINIO_SECURE", "false").lower() == "true"
)

def upload_file(bucket: str, object_name: str, file_path: str):
    """上传文件到 MinIO"""
    minio_client.fput_object(bucket, object_name, file_path)
    return f"http://localhost:9000/{bucket}/{object_name}"

def get_presigned_url(bucket: str, object_name: str, expires=3600):
    """生成预签名 URL（私有文件临时访问）"""
    return minio_client.presigned_get_object(bucket, object_name, expires=expires)
```

## 6. CDN 加速（可选）

### 6.1 配置 CDN 缓存

```nginx
# Nginx 配置示例
location /assets/ {
    proxy_pass http://minio:9000/assets-images/;
    proxy_cache cdn_cache;
    proxy_cache_valid 200 7d;
    proxy_cache_key $uri;
    add_header X-Cache-Status $upstream_cache_status;
}
```

### 6.2 图片懒加载

```typescript
// React 示例
<LazyLoad height={200}>
  <img 
    src={`${cdnUrl}/assets/${sku.cover_url}?size=thumbnail`}
    alt={sku.name}
    loading="lazy"
  />
</LazyLoad>
```

## 7. 安全策略

### 7.1 防盗链

```nginx
# Nginx 配置
valid_referers none blocked *.example.com;
if ($invalid_referer) {
    return 403;
}
```

### 7.2 访问控制

| Bucket | 访问策略 | 下载权限 |
|--------|---------|---------|
| assets-images | 公开读 | 所有人 |
| documents | 私有 | 仅上传者 + 管理员 |
| qrcodes | 私有 | 预签名 URL（临时） |

### 7.3 病毒扫描（可选）

```python
import clamd

def scan_file(file_path: str) -> bool:
    """使用 ClamAV 扫描病毒"""
    cd = clamd.ClamdUnixSocket()
    result = cd.scan(file_path)
    return result[file_path][0] == 'OK'
```

## 8. 前端上传组件

### 8.1 Ant Design Upload 示例

```typescript
import { Upload, message } from 'antd';
import { InboxOutlined } from '@ant-design/icons';

const { Dragger } = Upload;

function FileUploader({ category }: { category: string }) {
  const uploadProps = {
    name: 'file',
    multiple: false,
    action: `/api/v1/upload/${category}`,
    headers: {
      Authorization: `Bearer ${getToken()}`,
    },
    beforeUpload: (file) => {
      return validateFile(file, category);
    },
    onChange: (info) => {
      if (info.file.status === 'done') {
        message.success(`${info.file.name} 上传成功`);
        console.log(info.file.response.data.url);
      } else if (info.file.status === 'error') {
        message.error(`${info.file.name} 上传失败`);
      }
    },
  };
  
  return (
    <Dragger {...uploadProps}>
      <p className="ant-upload-drag-icon"><InboxOutlined /></p>
      <p>点击或拖拽文件到此区域上传</p>
    </Dragger>
  );
}
```

## 9. 清理策略

### 9.1 临时文件清理

```python
@celery.task
def cleanup_temp_uploads():
    """清理 24 小时前的临时上传"""
    cutoff = datetime.utcnow() - timedelta(hours=24)
    
    # 删除 MinIO 临时文件
    for obj in minio_client.list_objects("temp-uploads", recursive=True):
        if obj.last_modified < cutoff:
            minio_client.remove_object("temp-uploads", obj.object_name)
```

### 9.2 过期提货券清理

```python
@celery.task
def cleanup_expired_qrcodes():
    """清理 30 天前的提货券二维码"""
    cutoff = datetime.utcnow() - timedelta(days=30)
    
    for obj in minio_client.list_objects("qrcodes/pickup", recursive=True):
        if obj.last_modified < cutoff:
            minio_client.remove_object("qrcodes/pickup", obj.object_name)
```

## 10. 数据库关联

```sql
-- 文件上传记录表（可选）
CREATE TABLE file_upload_log (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  category VARCHAR(32) NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_size BIGINT NOT NULL,
  mime_type VARCHAR(64) NOT NULL,
  bucket VARCHAR(64) NOT NULL,
  object_key VARCHAR(512) NOT NULL,
  url VARCHAR(1024) NOT NULL,
  created_at DATETIME(3) NOT NULL,
  KEY idx_upload_user_time (user_id, created_at)
) ENGINE=InnoDB;
```
